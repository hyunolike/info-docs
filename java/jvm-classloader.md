## `updated by 2023/04/24` JVM의 클래스 로더 `class loader`
> [참고자료](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%A1%9C%EB%94%A9-%EC%B4%88%EA%B8%B0%ED%99%94-%EB%90%98%EB%8A%94%EA%B0%80-%E2%9D%93#jvm%EC%9D%98_%ED%81%B4%EB%9E%98%EC%8A%A4_%EB%A1%9C%EB%8D%94_class_loader)
- ![image](https://user-images.githubusercontent.com/61215550/234148054-619c9219-3e83-43a4-a745-1d5481697316.png)
- ⭐ 클래스 >> 메모리에 한번에 올리지 않음 !! >> 필요한 경우 동적으로 메모리에 적재하게 된다는 점
- 위 3가지 방법 >> 클래스 로드(loading)과 초기화(initialization) 다른 작업!
- ✔ JVM >> 실행될때 모든 클래스 메모리에 올려두지 않음 >> 필요한 클래스를 메모리에 올려 **효율적 관리**
### 클래스 로드 시점 파악
- 클래스 로딩: class loader >> `.class` 파일 찾고 JVM에 메모리에 올려놓는 것
- 클래스 초기화: static 블록, static 멤버 변수의 값 할당하는 것
  - new 생성자로 클래스를 인스턴스화 해야 클래스 초기화 되는 것 아님
  - 클래스 초기화 오직 한번만 수행 
- ⭐ 클래스 초기화 & 클래스 로드 시점과 거의 동시에 일어남

## JVM 구성요소 - `클래스 로더`
> [참고자료](https://velog.io/@jifrozen/JVM-%EA%B5%AC%EC%84%B1%EC%9A%94%EC%86%8C-1-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94)
### 구조
![image](https://user-images.githubusercontent.com/61215550/230240300-60fcaa98-93bf-42d5-833c-64994a5f53c0.png)

### 클래스 로더
- 동적으로 클래스 읽어옴
- 프로그램 실행 중인 런타임 >> 모든 코드가 자바 가상 머신과 연결
- ✔ 동적 로드 담당 >> JVM의 클래스 로더
- 클래스 로더 단계
  - 로딩
  - 링크
  - 초기화

#### 1. 부트스트랩 클래스로더
- JVM  시작 시 가장 `최초로 실행되는 클래스로더`
- 자바 클래스를 로드할 수 있는 자바 자체의 클래스로더와 최소한의 자바 클래스만을 로드
  - `java.lang.Object` `Class` `Classloader`
#### 2. 확장 클래스로더
- 부트스트랩 클래스로더를 부모로 갖는 클래스로더
- 확장 자바 클래스들 로드 

#### 3. 애플리케이션 클래스로더 
- 자바 프로그램 실행 시 지정한 `Classpath` 에 있는 클래스 파일 / Jar에 속한 클래스들을 로드

### 클래스 로더가 지켜야할 3가지 원칙
- 위임 법칙
  - 부모 클래스로더 방향으로 클래스 로딩을 위임하는 것
- 가시범위 법칙
  - 하위 클래스로더는 상위 클래스로더가 로드한 클래스를 볼 수 있지만, 반대로 상위 클래스로더는 하위 클래스로더가 로드한 클래스를 알 수 없음
- 유일성의 법칙
  - 하위 클래스로더가 상위 클래스로더에서 로드한 클래스를 다시 로드하지 않음

