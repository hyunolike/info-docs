## 클로져 `업데이트 2022/12/23`
> [참고자료](https://ko.javascript.info/closure)
- 자바스크립트 >> 함수 지향 언어 ✔
- ⭐**클로저**: `외부 변수` 를 기억하고 이 `외부 변수` 에 접근할 수 있는 함수
  - 자바스크립트 함수 >> `[[Environment]]` 이용 자신 어디서 만들어졌는지 기억!
### 😛렉시컬 환경
- 이론상의 객체
  - 직접 코드를 렉시컬 환경 조작 불가!
#### 1. 변수
> 특수 내부 객체인 환경 레코드의 프로퍼티 <br>
> 💡 '변수 가져오거나 변경' >> 환경 레코드의 프로퍼티 가져오거나 변경
- 코드 블록 `{...}`, 스크립트 객체 >> 렉시컬 환경(내부 숨김 연관 관계 `internal hidden associated`)
  - 환경 레코드: 모든 지역 변수를 프로퍼티로 저장하고 있는 객체 >> `this` 값과 같은 기타 정보도 저장!
  - 외부 렉시컬 환경: 외부 코드와 연관됨
#### 2. 함수 선언문
- 일반 변수와는 달리 **바로 초기화**
- ✔ 함수 표현식 ❌ `let say = () => ...`
#### 3. 내부와 외부 렉시컬 환경
- 함수 호출 실행 >> 새로운 렉시컬 환경 자동 생성
- ![image](https://user-images.githubusercontent.com/61215550/209264633-8f0db59d-ad61-4b54-b111-107f5d76d2ce.png)
#### 4. 함수를 반환하는 함수
- ![image](https://user-images.githubusercontent.com/61215550/209264766-f8a8e0ae-026b-4142-8a2f-f74bccd43039.png)
### 😛가비지 컬렉션
- 함수 호출 종료 >> 함수 대응하는 렉시컬 환경 메모리에서 제거!
  - 함수와 관련된 변수들 모두 삭제
- ✔ 자바스크립트의 모든 객체 >> 도달 가능한 상태일 때만 메모리 유지


```js
function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g가 살아있는 동안엔 연관 렉시컬 환경도 메모리에 살아있습니다.

g = null; // 도달할 수 없는 상태가 되었으므로 메모리에서 삭제됩니다.
```


### 😛최적화 프로세스
- 함수 살아있는 동안 `이론상` 모든 외부 변수 역시 메모리 유지!
  - ✌ 실제로는 자바스크립트 엔진 >> 지속적으로 최적화: 변수 사용 분석 및 외부 변수 사용 판단 여부에 따라 메모리에서 제거!!

---
> [참고자료](https://joshua1988.github.io/vue-camp/js/closure.html)
- 사전 개념: 스코프 `Scope` >> 식별자 접근 규첵에 따른 유효 범위
- ✔ 함수의 실행이 끝난 후에도 함수에 선언된 변수의 값을 접근할 수있는 자바스크립트의 성질 >> 다른 언어와의 유일한 특징!
- 클로져 개념 자체 >> 자바스크립트의 고유 개념 아님! - [참고자료](https://hanamon.kr/javascript-%ED%81%B4%EB%A1%9C%EC%A0%80/)
  - 여러 함수형 프로그래밍 언어에서의 공통적으로 발견되는 특성! 
- ⭐자신이 선언될 당시의 환경을 기억하는 함수 >> 이렇게 기억!!
- 클로저는 내부함수가 상위 스코프의 식별자를 참조! >> 그 상위 스코프 바깥에서 사용했을 때 그 상위 스코프의 식별자 수정할 수 없는 형태

### 클로져 만드는 2가지 형태
```javascript
// 클로저를 만드는 형태 1. - 중첩함수
function outerFn() {
  let x = 10;
  return function innerFn(y) { // innerFn 함수는 클로저다.
    return x = x + y;
  }
}
let a = outerFn(); // 외부함수 호출은 한번만. 이제 a 변수는 innerFn 함수를 참조한다.
a(5); // 15;
a(5); // 20;
a(5); // 25;

// 클로저를 만드는 형태 2. - 전역에 선언한 변수를 박스 안에서 함수로 정의하고 전역에서 호출
let globalFunc;
{
  let x = 10;
  globalFunc = function(y) { // globalFunc 함수는 클로저다.
    return x = x + y;
  }
}
globalFunc(5); // 15;
globalFunc(5); // 20;
globalFunc(5); // 25;
```
